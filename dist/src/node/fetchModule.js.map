{
  "version": 3,
  "sources": [
    "src/node/fetchModule.js"
  ],
  "names": [
    "https",
    "globalAgent",
    "options",
    "rejectUnauthorized",
    "isWindows",
    "process",
    "platform",
    "match",
    "fileUrlToPath",
    "fileUrl",
    "substr",
    "RangeError",
    "replace",
    "fetchModuleFromFileSystem",
    "key",
    "indexOf",
    "filePath",
    "Promise",
    "resolve",
    "reject",
    "fs",
    "readFile",
    "error",
    "buffer",
    "String",
    "then",
    "source",
    "status",
    "reason",
    "headers",
    "body",
    "undefined",
    "getHeaderMapFromResponse",
    "response",
    "headerMap",
    "forEach",
    "value",
    "name",
    "fetchModuleFromServer",
    "url",
    "parent",
    "text",
    "statusText",
    "fetchModule",
    "data",
    "Error"
  ],
  "mappings": "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",
  "sourcesContent": [
    "import fs from \"fs\"\nimport https from \"https\"\nimport fetch from \"node-fetch\"\n\nhttps.globalAgent.options.rejectUnauthorized = false\n\nconst isWindows =\n  typeof process !== \"undefined\" &&\n  typeof process.platform === \"string\" &&\n  process.platform.match(/^win/)\n\nconst fileUrlToPath = (fileUrl) => {\n  if (fileUrl.substr(0, 7) !== \"file://\") {\n    throw new RangeError(`${fileUrl} is not a valid file url`)\n  }\n  if (isWindows) {\n    return fileUrl.substr(8).replace(/\\\\/g, \"/\")\n  }\n  return fileUrl.substr(7)\n}\n\nconst fetchModuleFromFileSystem = (key) => {\n  if (key.indexOf(\"file:\") === 0) {\n    const filePath = fileUrlToPath(key)\n    return new Promise((resolve, reject) => {\n      fs.readFile(filePath, (error, buffer) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve(String(buffer))\n        }\n      })\n    }).then((source) => {\n      return { status: 200, reason: \"\", headers: {}, body: source }\n    })\n  }\n  return undefined\n}\n\nconst getHeaderMapFromResponse = (response) => {\n  const headerMap = {}\n  response.headers.forEach((value, name) => {\n    headerMap[name] = value\n  })\n  return headerMap\n}\n\nconst fetchModuleFromServer = (url, parent) => {\n  if (url.indexOf(\"http:\") === 0 || url.indexOf(\"https:\") === 0) {\n    return fetch(url, {\n      headers: {\n        \"x-module-referer\": parent || url,\n      },\n    }).then((response) =>\n      response.text().then((text) => {\n        return {\n          status: response.status,\n          reason: response.statusText,\n          headers: getHeaderMapFromResponse(response),\n          body: text,\n        }\n      }),\n    )\n  }\n  return undefined\n}\n\nexport const fetchModule = (url, parent) => {\n  return Promise.resolve(fetchModuleFromFileSystem(url, parent)).then((data) => {\n    return data\n      ? data\n      : Promise.resolve(fetchModuleFromServer(url, parent)).then((data) => {\n          if (data) {\n            return data\n          }\n          throw new Error(`unsupported protocol for module ${url}`)\n        })\n  })\n}\n"
  ]
}